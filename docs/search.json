[
  {
    "objectID": "chapter_1.html",
    "href": "chapter_1.html",
    "title": "1  Creating a ggplot",
    "section": "",
    "text": "#Basics of ggplot2\nThis chapter focuses on ggplot2, one of the core packages in the tidyverse. Load the tidyverse by running:\n\npacman::p_load(\"tidyverse\",\n               \"ggthemes\"\n               )\n\nWe will use penguins data frame. A data frame is a rectangular collection of variables (in the columns) and observations (in the rows). penguins contains 344 observations.\n\npenguins &lt;- read.csv(\"data/penguins.csv\")\n\n\nFor an alternative view, where you can see all variables and the first few observations of each variable, use glimpse(). Or by using view(), you can see the data in a different tab with all information.\n\n\nglimpse(penguins)\n\nRows: 344\nColumns: 9\n$ rowid             &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1…\n$ species           &lt;chr&gt; \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"A…\n$ island            &lt;chr&gt; \"Torgersen\", \"Torgersen\", \"Torgersen\", \"Torgersen\", …\n$ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …\n$ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …\n$ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…\n$ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …\n$ sex               &lt;chr&gt; \"male\", \"female\", \"female\", NA, \"female\", \"male\", \"f…\n$ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…\n\n\n\nview(penguins)\n\nLet’s recreate this plot step-by-step.\nWith ggplot2, you begin a plot with the function ggplot(), defining a plot object that you then add layers to. The first argument of ggplot() is the dataset to use in the graph and so ggplot(data = penguins) creates an empty graph that is primed to display the penguins data, but since we haven’t told it how to visualize it yet, for now it’s empty. This is not a very exciting plot, but you can think of it like an empty canvas you’ll paint the remaining layers of your plot onto.\n\nggplot(data = penguins)\n\n\n\n\nNext, we need to tell ggplot() how the information from our data will be visually represented. The mapping argument of the ggplot() function defines how variables in your dataset are mapped to visual properties (aesthetics) of your plot. The mapping argument is always defined in the aes() function, and the x and y arguments of aes() specify which variables to map to the x and y axes. For now, we will only map flipper length to the x aesthetic and body mass to the y aesthetic. ggplot2 looks for the mapped variables in the data argument, in this case, penguins.\nThe following plot shows the result of adding these mappings.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n)\n\n\n\n\nOur empty canvas now has more structure – it’s clear where flipper lengths will be displayed (on the x-axis) and where body masses will be displayed (on the y-axis). But the penguins themselves are not yet on the plot. This is because we have not yet articulated, in our code, how to represent the observations from our data frame on our plot.\nTo do so, we need to define a geom: the geometrical object that a plot uses to represent data. These geometric objects are made available in ggplot2 with functions that start with geom_. People often describe plots by the type of geom that the plot uses. For example, bar charts use bar geoms (geom_bar()), line charts use line geoms (geom_line()), boxplots use boxplot geoms (geom_boxplot()), scatterplots use point geoms (geom_point()), and so on.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nNow we have something that looks like what we might think of as a “scatterplot”. It doesn’t yet match our “ultimate goal” plot.\nWe’re seeing the warning message because there are two penguins in our dataset with missing body mass and/or flipper length values and ggplot2 has no way of representing them on the plot without both of these values.\nLet’s incorporate species into our plot and see if this reveals any additional insights into the apparent relationship between these variables. We will do this by representing species with different colored points.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point()\n\n\n\n\nNow let’s add one more layer: a smooth curve displaying the relationship between body mass and flipper length.\nSince this is a new geometric object representing our data, we will add a new geom as a layer on top of our point geom: geom_smooth(). And we will specify that we want to draw the line of best fit based on a linear model with method = “lm”.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\n\n\n\nWhen aesthetic mappings are defined in ggplot(), at the global level, they’re passed down to each of the subsequent geom layers of the plot. However, each geom function in ggplot2 can also take a mapping argument, which allows for aesthetic mappings at the local level that are added to those inherited from the global level. Since we want points to be colored based on species but don’t want the lines to be separated out for them, we should specify color = species for geom_point() only.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species)) +\n  geom_smooth(method = \"lm\")\n\n\n\n\nIt’s generally not a good idea to represent information using only colors on a plot, as people perceive colors differently due to color blindness or other color vision differences. Therefore, in addition to color, we can also map species to the shape aesthetic.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species, shape = species)) +\n  geom_smooth(method = \"lm\")\n\n\n\n\nAnd finally, we can improve the labels of our plot using the labs() function in a new layer. Some of the arguments to labs() might be self explanatory: title adds a title and subtitle adds a subtitle to the plot. Other arguments match the aesthetic mappings, x is the x-axis label, y is the y-axis label, and color and shape define the label for the legend. In addition, we can improve the color palette to be colorblind safe with the scale_color_colorblind() function from the ggthemes package.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(aes(color = species, shape = species)) +\n  geom_smooth(method = \"lm\") +\n  labs(\n    title = \"Body mass and flipper length\",\n    subtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\",\n    x = \"Flipper length (mm)\", y = \"Body mass (g)\",\n    color = \"Species\", shape = \"Species\"\n  ) +\n  scale_color_colorblind()"
  },
  {
    "objectID": "chapter_1.html#creating-a-ggplot",
    "href": "chapter_1.html#creating-a-ggplot",
    "title": "1  Chapter 1",
    "section": "1.1 Creating a ggplot",
    "text": "1.1 Creating a ggplot\nLet’s recreate this plot step-by-step.\nWith ggplot2, you begin a plot with the function ggplot(), defining a plot object that you then add layers to. The first argument of ggplot() is the dataset to use in the graph and so ggplot(data = penguins) creates an empty graph that is primed to display the penguins data, but since we haven’t told it how to visualize it yet, for now it’s empty. This is not a very exciting plot, but you can think of it like an empty canvas you’ll paint the remaining layers of your plot onto.\n\nggplot(data = penguins)\n\n\n\n\nNext, we need to tell ggplot() how the information from our data will be visually represented. The mapping argument of the ggplot() function defines how variables in your dataset are mapped to visual properties (aesthetics) of your plot. The mapping argument is always defined in the aes() function, and the x and y arguments of aes() specify which variables to map to the x and y axes. For now, we will only map flipper length to the x aesthetic and body mass to the y aesthetic. ggplot2 looks for the mapped variables in the data argument, in this case, penguins.\nThe following plot shows the result of adding these mappings.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n)\n\n\n\n\nOur empty canvas now has more structure – it’s clear where flipper lengths will be displayed (on the x-axis) and where body masses will be displayed (on the y-axis). But the penguins themselves are not yet on the plot. This is because we have not yet articulated, in our code, how to represent the observations from our data frame on our plot.\nTo do so, we need to define a geom: the geometrical object that a plot uses to represent data. These geometric objects are made available in ggplot2 with functions that start with geom_. People often describe plots by the type of geom that the plot uses. For example, bar charts use bar geoms (geom_bar()), line charts use line geoms (geom_line()), boxplots use boxplot geoms (geom_boxplot()), scatterplots use point geoms (geom_point()), and so on.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nNow we have something that looks like what we might think of as a “scatterplot”. It doesn’t yet match our “ultimate goal” plot.\nWe’re seeing the warning message because there are two penguins in our dataset with missing body mass and/or flipper length values and ggplot2 has no way of representing them on the plot without both of these values.\nLet’s incorporate species into our plot and see if this reveals any additional insights into the apparent relationship between these variables. We will do this by representing species with different colored points.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point()\n\n\n\n\nNow let’s add one more layer: a smooth curve displaying the relationship between body mass and flipper length.\nSince this is a new geometric object representing our data, we will add a new geom as a layer on top of our point geom: geom_smooth(). And we will specify that we want to draw the line of best fit based on a linear model with method = “lm”.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\n\n\n\nWhen aesthetic mappings are defined in ggplot(), at the global level, they’re passed down to each of the subsequent geom layers of the plot. However, each geom function in ggplot2 can also take a mapping argument, which allows for aesthetic mappings at the local level that are added to those inherited from the global level. Since we want points to be colored based on species but don’t want the lines to be separated out for them, we should specify color = species for geom_point() only.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species)) +\n  geom_smooth(method = \"lm\")\n\n\n\n\nIt’s generally not a good idea to represent information using only colors on a plot, as people perceive colors differently due to color blindness or other color vision differences. Therefore, in addition to color, we can also map species to the shape aesthetic.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(mapping = aes(color = species, shape = species)) +\n  geom_smooth(method = \"lm\")\n\n\n\n\nAnd finally, we can improve the labels of our plot using the labs() function in a new layer. Some of the arguments to labs() might be self explanatory: title adds a title and subtitle adds a subtitle to the plot. Other arguments match the aesthetic mappings, x is the x-axis label, y is the y-axis label, and color and shape define the label for the legend. In addition, we can improve the color palette to be colorblind safe with the scale_color_colorblind() function from the ggthemes package.\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(aes(color = species, shape = species)) +\n  geom_smooth(method = \"lm\") +\n  labs(\n    title = \"Body mass and flipper length\",\n    subtitle = \"Dimensions for Adelie, Chinstrap, and Gentoo Penguins\",\n    x = \"Flipper length (mm)\", y = \"Body mass (g)\",\n    color = \"Species\", shape = \"Species\"\n  ) +\n  scale_color_colorblind()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Science and Economics",
    "section": "",
    "text": "Preface\nData Science and Economics"
  },
  {
    "objectID": "chapter_2.html",
    "href": "chapter_2.html",
    "title": "2  More on ggplot2",
    "section": "",
    "text": "#Chapter 2\nLoad necessary packages for this chapter:\n\npacman::p_load(\"tidyverse\",\n               \"ggthemes\"\n               )\n\nWe will use the penguins data set which contains 344 observations.\n\npenguins &lt;- read.csv(\"data/penguins.csv\")\n\nAs we move on from these introductory sections, we’ll transition to a more concise expression of ggplot2 code. So far we’ve been very explicit, which is helpful when you are learning:\nExpression 1:\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n\n\n\n\nTypically, the first one or two arguments to a function are so important that you should know them by heart. The first two arguments to ggplot() are data and mapping, in the remainder of the book, we won’t supply those names. That saves typing, and, by reducing the amount of extra text, makes it easier to see what’s different between plots.\nExpression 2:\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) + \n  geom_point()\n\n\n\n\nWe can also use the pipe, |&gt;, which will allow you to create that plot.\nExpression 3:\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm, y = body_mass_g)) + \n  geom_point()"
  },
  {
    "objectID": "chapter_2.html#ggplot2-calls",
    "href": "chapter_2.html#ggplot2-calls",
    "title": "Chapter 2",
    "section": "",
    "text": "As we move on from these introductory sections, we’ll transition to a more concise expression of ggplot2 code. So far we’ve been very explicit, which is helpful when you are learning:\nExpression 1:\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point()\n\n\n\n\nTypically, the first one or two arguments to a function are so important that you should know them by heart. The first two arguments to ggplot() are data and mapping, in the remainder of the book, we won’t supply those names. That saves typing, and, by reducing the amount of extra text, makes it easier to see what’s different between plots.\nExpression 2:\n\nggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) + \n  geom_point()\n\n\n\n\nWe can also use the pipe, |&gt;, which will allow you to create that plot.\nExpression 3:\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm, y = body_mass_g)) + \n  geom_point()"
  },
  {
    "objectID": "chapter_3.html",
    "href": "chapter_3.html",
    "title": "3  Chapter 3",
    "section": "",
    "text": "4 Difference in Differences\npacman::p_load(tidyverse,\n               knitr)"
  },
  {
    "objectID": "chapter_3.html#wide-and-long-data-formats",
    "href": "chapter_3.html#wide-and-long-data-formats",
    "title": "3  Difference in Differences",
    "section": "3.1 Wide and long data formats",
    "text": "3.1 Wide and long data formats\nWide data set:\n\ncity_wide_df &lt;- read.csv(\"data/city_wide.csv\")\ncity_wide_df %&gt;% knitr::kable() %&gt;% kableExtra::kable_styling()\n\n\n\n\ncity\npop_2000\npop_2010\npop_2020\n\n\n\n\nBerlin\n3.38\n3.45\n3.56\n\n\nRome\n3.70\n3.96\n4.26\n\n\nParis\n9.74\n10.46\n11.01\n\n\nLondon\n7.27\n8.04\n9.30\n\n\n\n\n\n\n\n\ncity_long_df &lt;- read.csv(\"data/city_long.csv\")\ncity_long_df %&gt;% knitr::kable() %&gt;% kableExtra::kable_styling()\n\n\n\n\ncity\nyear\npop\n\n\n\n\nBerlin\n2000\n3.38\n\n\nBerlin\n2010\n3.45\n\n\nBerlin\n2020\n3.56\n\n\nRome\n2000\n3.70\n\n\nRome\n2010\n3.96\n\n\nRome\n2020\n4.26\n\n\nParis\n2000\n9.74\n\n\nParis\n2010\n10.46\n\n\nParis\n2020\n11.01\n\n\nLondon\n2000\n7.27\n\n\nLondon\n2010\n8.04\n\n\nLondon\n2020\n9.30\n\n\n\n\n\n\n\nConvert “city_wide_df” to long data set\n\ncity_wide_df %&gt;%\n  tidyr::pivot_longer(\n    cols = c(pop_2000, pop_2010, pop_2020), # -city, !city, starts_with(pop_), etc... would also work\n    names_to = \"year\", # where do we want the names of the columns to go? (year)\n    names_prefix = \"pop_\", # names_prefix removes matching text from the start of each variable name (not always necessary)\n    values_to = \"pop\" # where do we want the values in the columns to go? (pop)\n  )\n\n# A tibble: 12 × 3\n   city      year    pop\n   &lt;chr&gt;     &lt;chr&gt; &lt;dbl&gt;\n 1 \"Berlin \" 2000   3.38\n 2 \"Berlin \" 2010   3.45\n 3 \"Berlin \" 2020   3.56\n 4 \"Rome \"   2000   3.7 \n 5 \"Rome \"   2010   3.96\n 6 \"Rome \"   2020   4.26\n 7 \"Paris \"  2000   9.74\n 8 \"Paris \"  2010  10.5 \n 9 \"Paris \"  2020  11.0 \n10 \"London \" 2000   7.27\n11 \"London \" 2010   8.04\n12 \"London \" 2020   9.3 \n\n\n\n3.1.1 Why do we care about the data format\nIn some instances long format datasets are required for advanced statistical analysis and graphing. For example, if we wanted to run the regression formulation of the difference in differences model, we would need to input our data in long format. Furthermore, having our data in long format is very useful when plotting. Packages such as ggplot2, expect that your data will be in long form for the most part.\n\nlibrary(dplyr) # to wrangle our data\nlibrary(tidyr) # to wrangle our data - pivot_longer()\nlibrary(ggplot2) # to render our graphs\nlibrary(readr) # for loading the .csv data\nlibrary(kableExtra) # to render better formatted tables\n\n\nAttaching package: 'kableExtra'\n\n\nThe following object is masked from 'package:dplyr':\n\n    group_rows\n\nlibrary(stargazer) # for formatting your model output\n\n\nPlease cite as: \n\n\n Hlavac, Marek (2022). stargazer: Well-Formatted Regression and Summary Statistics Tables.\n\n\n R package version 5.2.3. https://CRAN.R-project.org/package=stargazer \n\nlibrary(lmtest) # to gather our clustered standard errors - coeftest()\n\nLoading required package: zoo\n\n\n\nAttaching package: 'zoo'\n\n\nThe following objects are masked from 'package:base':\n\n    as.Date, as.Date.numeric\n\nlibrary(plm)  # to gather our clustered standard errors - vcovHC()\n\n\nAttaching package: 'plm'\n\n\nThe following objects are masked from 'package:dplyr':\n\n    between, lag, lead\n\n\n\nsoda_tax_df &lt;- read.csv(\"data/soda_tax_df.csv\")\n\nAre this wide or long data\n\nsoda_tax_df %&gt;% head(10)\n\n   id     district treatment   pre_tax  post_tax\n1   1 Snake Lounge         0 1687.6438 1705.5791\n2   2 Snake Lounge         0  427.2953  438.2526\n3   3 Snake Lounge         0  566.4693  559.6664\n4   4 Snake Lounge         0  606.9294  623.9057\n5   5 Snake Lounge         0  572.6402  606.8654\n6   6 Snake Lounge         0  496.0813  501.8001\n7   7 Snake Lounge         0  658.7283  670.4385\n8   8 Snake Lounge         0  497.8011  522.3219\n9   9 Snake Lounge         0  814.7636  846.2049\n10 10 Snake Lounge         0  502.5929  509.9525\n\n\nOur soda_tax_df is in wide format. We can convert our data to a long format to render the time and treatment dummy variables and save is to the soda_tax_df_long.\nWe will utilize the pivot_longer() function from tidyr to format our data frame.\n\nsoda_tax_df_long &lt;- \n  soda_tax_df %&gt;% # the wide format df\n  tidyr::pivot_longer(cols = c(pre_tax, post_tax), # both contain information about soda drank at two points in time\n                      names_to = \"period\", # grab the names of pre and post and save them to period\n                      values_to = \"soda_drank\") %&gt;% # grab values from pre and post and put them in soda_drank\n  dplyr::mutate(after_tax = ifelse(period == \"post_tax\", 1, 0)) # create dummy for period\n\nhead(soda_tax_df_long, 10)\n\n# A tibble: 10 × 6\n      id district     treatment period   soda_drank after_tax\n   &lt;int&gt; &lt;chr&gt;            &lt;int&gt; &lt;chr&gt;         &lt;dbl&gt;     &lt;dbl&gt;\n 1     1 Snake Lounge         0 pre_tax       1688.         0\n 2     1 Snake Lounge         0 post_tax      1706.         1\n 3     2 Snake Lounge         0 pre_tax        427.         0\n 4     2 Snake Lounge         0 post_tax       438.         1\n 5     3 Snake Lounge         0 pre_tax        566.         0\n 6     3 Snake Lounge         0 post_tax       560.         1\n 7     4 Snake Lounge         0 pre_tax        607.         0\n 8     4 Snake Lounge         0 post_tax       624.         1\n 9     5 Snake Lounge         0 pre_tax        573.         0\n10     5 Snake Lounge         0 post_tax       607.         1\n\n\n\n\n3.1.2 Exploring our data\nWe can use our soda_tax_df to explore the distribution of soda consumption at different points in time.\nLet’s try first to look at the differences in the distribution only at the\n\n3.1.2.1 pre-tax time period:\n\nggplot(soda_tax_df, aes(x = pre_tax, fill = factor(treatment))) + \n  geom_density(alpha = 0.5) + # density plot with transparency (alpha = 0.5)\n  scale_fill_manual(name = \" \", # changes to fill dimension\n                     values = c(\"#a7a8aa\", \"#cc0055\"),\n                     labels = c(\"Control\", \"Treatment\")) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\") +\n  labs(title = \"Distribution of soda consumption before the tax was imposed\",\n       x = \"Soda consumtion (oz)\",\n       y = \"Density\")\n\n\n\n\nLet’s look at the\n\n\n3.1.2.2 post-tax period:\n\nggplot(soda_tax_df, aes(x = post_tax, fill = factor(treatment))) + \n  geom_density(alpha = 0.5) + # density plot with transparency (alpha = 0.5)\n  scale_fill_manual(name = \" \", # changes to fill dimension\n                     values = c(\"#a7a8aa\", \"#cc0055\"),\n                     labels = c(\"Control\", \"Treatment\")) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\") +\n  labs(title = \"Distribution of soda consumption after the tax was imposed\",\n       x = \"Soda consumtion (oz)\",\n       y = \"Density\")\n\n\n\n\nSince in our soda_tax_df_long we represent the time and soda consumption dimensions under the same columns, we can create even more complex graphs.\n\n\n3.1.2.3 grammar of graphs: Facets\nWe will use facet_grid() which forms a matrix of panels defined by row and column faceting variables. It is most useful when you have two discrete variables, and all combinations of the variables exist in the data.\n\nsoda_tax_df_long %&gt;% \n  dplyr::mutate(period = ifelse(period == \"post_tax\", \"T1 - Post-tax\", \"T0 - Pre-tax\"), # create more meaningful labels\n                treatment = ifelse(treatment == 1, \"Treated (D=1)\", \"Untreated (D=0)\")) %&gt;%\n  dplyr::group_by(period, treatment) %&gt;% # group to extract means of each group at each time\n  dplyr::mutate(group_mean = mean(soda_drank)) %&gt;% # extract means of each group at each time\nggplot(., aes(x = soda_drank, fill = factor(treatment))) +\n  geom_density(alpha = 0.5) +\n  scale_fill_manual(name = \" \", # changes to fill dimension\n                     values = c(\"#cc0055\", \"#a7a8aa\"),\n                     labels = c(\"Treatment\", \"Control\")) +\n  facet_grid(treatment~period) + # we specify the matrix (treatment and period)\n  geom_vline(aes(xintercept = group_mean), linetype = \"longdash\") + # add vertical line with the mean\n  theme_bw() +\n  theme(legend.position = \"none\") +\n  labs(x = \"Soda consumed (oz)\",\n       y = \"Density\")\n\n\n\n\n\n\n\n3.1.3 Modeling and estimating\nSo far we have ignored time in our estimations. Difference-in-differences compares the changes in outcomes over time between units under different treatment states. This allows us to correct for any differences between the treatment and comparison groups that are constant over time assuming that the trends in time are parallel.\n\n3.1.3.1 Calculating without time\nIf we did not have the pre_tax baseline measure, we would likely utilize the post_tax to explore the average effect on the treated. In this case, we would model this as:\n\nafter_model &lt;- lm(post_tax ~ treatment, data = soda_tax_df)\nstargazer(after_model, type = \"text\")\n\n\n===============================================\n                        Dependent variable:    \n                    ---------------------------\n                             post_tax          \n-----------------------------------------------\ntreatment                   -146.918***        \n                              (3.798)          \n                                               \nConstant                    523.273***         \n                              (2.686)          \n                                               \n-----------------------------------------------\nObservations                   7,500           \nR2                             0.166           \nAdjusted R2                    0.166           \nResidual Std. Error     164.465 (df = 7498)    \nF Statistic         1,496.245*** (df = 1; 7498)\n===============================================\nNote:               *p&lt;0.1; **p&lt;0.05; ***p&lt;0.01\n\n\nWe could read this result substantively as: those who lived in districts were the tax was implemented consumed on average 146.9 ounces less of sugar-added drinks per week compared to those who lived in districts were the tax was not put in place. This calculation would give us a comparison of the treatment and control groups after treatment.\nWe would have to think carefully about possible factors that could differentiate our treatment and control groups. We use a treatment indicator based on the districts where the measure was able to be implemented. Treatment was not fully randomly assigned, so there may be lots of potential confounders that create baseline differences in the scores for those living in Old Eagleton compared to those in Snake Lounge, which also affect the after-treatment comparisons.\nIf we think about the mechanics behind this naive calculation, we are just comparing the average observed outcomes for those treated and not treated after the tax was imposed:\n\n\n\nTreatment\nAverage after tax\n\n\n\n\n0\n523.2726\n\n\n1\n376.3548\n\n\n\n\nggplot(soda_tax_df, aes(x = post_tax, fill = factor(treatment))) +\n  geom_density(alpha = 0.5) +\n  scale_fill_manual(name = \" \", # changes to fill dimension\n                     values = c(\"#a7a8aa\", \"#cc0055\"),\n                     labels = c(\"Control\", \"Treatment\")) +\n  geom_vline(xintercept = 523.27, linetype = \"longdash\", color = \"#a7a8aa\") + #avg for the untreated\n  geom_vline(xintercept = 376.35, linetype = \"longdash\", color = \"#cc0055\") + #avg for the treated\n  theme_minimal() +\n  theme(legend.position = \"bottom\") +\n  labs(title = \"Distribution of soda consumption after the tax was imposed\",\n       x = \"Soda consumtion (oz)\",\n       y = \"Density\")\n\n\n\n\n\n\n3.1.3.2 Including the time dimension (Manual extraction of the DiD estimate)\n\n\n\nTreatment\nPre-tax\nPost-tax\nDifference\n\n\n\n\n1\n511.13\n376.35\n-134.78\n\n\n0\n508.31\n523.27\n14.97\n\n\n\nWe can just manually substract:\n\\[ DiD = -134.79 -14.97 = -149.76\\]\n\n\n3.1.3.3 Including the time dimension\nWe can introduce the time component to our calculation by incorporating the pre-treatment levels of sugar-added drink consumption, which gives us the diff-in-diff estimand. We could calculate this in a fairly straightforward manner by creating a variable assessing the change in our wide format data frame:\n\nchange: The difference in sugar-added drink consuption between post- and pre-tax\n\n\nsoda_tax_df &lt;- soda_tax_df %&gt;%\n  dplyr::mutate(change = post_tax - pre_tax) #simple substraction\n\ndid_model &lt;- lm(change ~ treatment, data = soda_tax_df)\nstargazer(did_model, after_model, type = \"text\")\n\n\n============================================================\n                                    Dependent variable:     \n                                ----------------------------\n                                    change        post_tax  \n                                      (1)           (2)     \n------------------------------------------------------------\ntreatment                         -149.744***   -146.918*** \n                                    (0.246)       (3.798)   \n                                                            \nConstant                           14.967***     523.273*** \n                                    (0.174)       (2.686)   \n                                                            \n------------------------------------------------------------\nObservations                         7,500         7,500    \nR2                                   0.980         0.166    \nAdjusted R2                          0.980         0.166    \nResidual Std. Error (df = 7498)     10.671        164.465   \nF Statistic (df = 1; 7498)      369,242.400***  1,496.245***\n============================================================\nNote:                            *p&lt;0.1; **p&lt;0.05; ***p&lt;0.01\n\n\nWe could read this result substantively as: those who lived in districts were the tax was implemented consumed on average 149.7 ounces less of sugar-added drinks per week compared to those who lived in districts were the tax was not put in place. This calculation would give us the change, or difference, in sugar-added drink consumption for treatment and control groups.\nTo believe the results of our did_model, we would need to believe that there are parallel trends between the two groups.\n\n\n3.1.3.4 Including the time dimension (Regression formulation of the DiD model)\nWe can re-format our data to gather our diff-in-diff estimate\n\\[ Y_{it} = ......\\]\nFor this calculation we need our data in long format to use the time and treatment dummy variables. We can see that under our long format, we have two entries for every individual.\n\ndid_long &lt;- lm(soda_drank ~ treatment + after_tax + treatment*after_tax, data = soda_tax_df_long) #running our model\n\ndid_long_clustered_se &lt;- coeftest(did_long, vcov=vcovHC(did_long,type=\"HC0\",cluster=\"district\")) #clustering out standard errors at the district level\n\nstargazer::stargazer(did_long_clustered_se, type = \"text\")\n\n\n===============================================\n                        Dependent variable:    \n                    ---------------------------\n                                               \n-----------------------------------------------\ntreatment                      2.827           \n                              (3.799)          \n                                               \nafter_tax                    14.967***         \n                              (3.836)          \n                                               \ntreatment:after_tax         -149.744***        \n                              (5.372)          \n                                               \nConstant                    508.306***         \n                              (2.708)          \n                                               \n===============================================\n===============================================\nNote:               *p&lt;0.1; **p&lt;0.05; ***p&lt;0.01\n\n\n\nsoda_tax_df_long %&gt;% \n  dplyr::mutate(period = ifelse(period == \"post_tax\", \"T1 - Post-tax\", \"T0 - Pre-tax\"), # create more meaningful labels\n                treatment = ifelse(treatment == 1, \"Treated (D=1)\", \"Untreated (D=0)\")) %&gt;%\n  dplyr::group_by(period, treatment) %&gt;% # group to extract means of each group at each time\n  dplyr::mutate(group_mean = mean(soda_drank)) %&gt;% # extract means of each group at each time\nggplot(., aes(x = soda_drank, fill = factor(treatment))) +\n  geom_density(alpha = 0.5) +\n  scale_fill_manual(name = \" \", # changes to fill dimension\n                     values = c(\"#cc0055\", \"#a7a8aa\"),\n                     labels = c(\"Treatment\", \"Control\")) +\n  facet_grid(treatment~period) + # we specify the matrix (treatment and period)\n  geom_vline(aes(xintercept = group_mean), linetype = \"longdash\") + # add vertical line with the mean\n  theme_bw() +\n  theme(legend.position = \"none\") +\n  labs(x = \"Soda consumed (oz)\",\n       y = \"Density\")\n\n\n\n\n\nsoda_tax_df_long %&gt;%\n  dplyr::group_by(period, treatment) %&gt;% # group to extract means of each group at each time\n  dplyr::mutate(group_mean = mean(soda_drank)) %&gt;%\n  ggplot(aes(x = after_tax, y = group_mean, color = factor(treatment))) +\n  geom_point() +\n  geom_line(aes(x = after_tax, y = group_mean)) +\n  scale_x_continuous(breaks = c(0,1)) +\n  scale_color_manual(name = \" \", # changes to color dimension\n                     values = c(\"#a7a8aa\", \"#cc0055\"),\n                     labels = c(\"Control\", \"Treatment\")) +\n  labs(x = \"Time periods\", y = \"Ounces of soda drank per week\", color = \"Treatment group\")+\n  theme_minimal() \n\n\n\n\n\nDrafting some brief recommedations\n\nBased on your analysis of the data at hand, you decide to recommend that the tax measure should move forward in the rest of Pawnee. You state that it is a very good example of a pigouvian tax, which captures the negative externalities not included in the market price of sugar-added drinks. The findings suggest that the tax reduced the weekly sugar-added drink consumption by about 150 luquid ounces (almost 4.5 liters)."
  },
  {
    "objectID": "chapter_4.html#basic-2d-vann-diagram",
    "href": "chapter_4.html#basic-2d-vann-diagram",
    "title": "4  Create simple vann diagram by using R",
    "section": "4.1 Basic 2D Vann diagram:",
    "text": "4.1 Basic 2D Vann diagram:\n\nx &lt;- list(A = 1:5, B = 2:7)\nggVennDiagram(x)"
  },
  {
    "objectID": "chapter_4.html#d-venn-diagram",
    "href": "chapter_4.html#d-venn-diagram",
    "title": "4  Create simple vann diagram by using R",
    "section": "4.2 3D Venn diagram:",
    "text": "4.2 3D Venn diagram:\nIf you pass a list with three elements you will get some Venn diagram like the following\n\nx &lt;- list(A = 1:5, B = 2:7, C = 5:10)\nggVennDiagram(x)"
  },
  {
    "objectID": "chapter_4.html#changing-the-colors-of-the-diagram",
    "href": "chapter_4.html#changing-the-colors-of-the-diagram",
    "title": "4  Create simple vann diagram by using R",
    "section": "4.3 Changing the colors of the diagram",
    "text": "4.3 Changing the colors of the diagram\n\nAs ggVennDiagram is based on ggplot2 you can add more layers or override the ones existing. In order to change the colors use scale_fill_gradient as in the following example:\n\n\nx &lt;- list(A = 1:5, B = 2:7, C = 5:10)\nggVennDiagram(x) + \n  scale_fill_gradient(low = \"#F4FAFE\", high = \"#4981BF\") \n\n\n\n\n\nThe border can also be customized but making use of color argument. The line width and line style can be changed with lwd and lty, respectively."
  },
  {
    "objectID": "chapter_4.html#labels-and-group-names",
    "href": "chapter_4.html#labels-and-group-names",
    "title": "4  Create simple vann diagram by using R",
    "section": "4.4 Labels and group names",
    "text": "4.4 Labels and group names\n\nx &lt;- list(A = 1:5, B = 2:7, C = 5:10)\nggVennDiagram(x, category.names = c(\"A\",\n                                    \"B\",\n                                    \"C\"))\n\n\n\n\n\nLabels with percentages\n\n\nx &lt;- list(A = 1:5, B = 2:7, C = 5:10)\nggVennDiagram(x, \n              label = \"percent\",\n              category.names = c(\"A\",\n                                    \"B\",\n                                    \"C\")) \n\n\n\n\n\nRemove the labels\n\n\nx &lt;- list(A = 1:5, B = 2:7, C = 5:10)\nggVennDiagram(x, \n              label = \"none\",\n              category.names = c(\"A\",\n                                    \"B\",\n                                    \"C\")) \n\n\n\n\n-Customize the legend\n\nx &lt;- list(A = 1:5, B = 2:7, C = 5:10)\nggVennDiagram(x) + \n  guides(fill = guide_legend(title = \"Title\")) +\n  theme(legend.title = element_text(color = \"black\"),\n        legend.position = \"bottom\")"
  },
  {
    "objectID": "chapter_4.html#d-venn-diagram-1",
    "href": "chapter_4.html#d-venn-diagram-1",
    "title": "4  Create simple vann diagram by using R",
    "section": "4.5 4D Venn diagram",
    "text": "4.5 4D Venn diagram\nYou can also pass a list with up to four different elements.\n\nx &lt;- list(A = 1:5, B = 2:7, C = 5:10, D = 8:15)\nggVennDiagram(x)"
  }
]